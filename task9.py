## Варіант 1 з можливістю брати будь-яку кількість обходів і кішок.
## Цей той варіант, до якого я додумався сам. Я розумів, що O(n^2) це дуже багато - в даному випадку це 10 000 ітерацій.
## Тому намагався знайти інший, швидший і ергономічніший.

def cats_and_hats(cats: int, rounds: int) -> list:
    cats_with_hats = []
    for i in range(1, rounds + 1):
        for j in range(1, cats + 1):
            if j % i == 0 and j not in cats_with_hats:
                cats_with_hats.append(j)
            elif j % i == 0 and j in cats_with_hats:
                cats_with_hats.remove(j)
    return cats_with_hats

## Варіант 2. Я був близький до цього рішення після знаходження першого - я звернув увагу на те, що всі ітогові числа кішок при виконанні
## варіанту коду зверху є квадратами чисел від 1 до 10. Я зрозумів, що тільки квадрат може в кінці опинитися "в шляпі". Втім, брак моєї 
## математичної інтуіції не дозволив мені зуміти це пояснити. З допомогою інтернету я з'ясував, що після першого обходу кішок, у якому на
## кожну з них ми наділи шляпу, ітоговий результат того, будуть вони в шляпах чи ні залежав від того, чи буде кількість ітерацій обрання 
## цих кішок парною. Це, в свою чергу, можливо тільки тоді, коли кількість дільників (крім одиниці)конкретного номеру кішки є парним.
## А така умова можлива тоді і тільки тоді, коли цей номер складає квадрат числа від 1 до 10 (в даному випадку).

def cats_and_hats():
    return [i*i for i in range(1, 11)]
